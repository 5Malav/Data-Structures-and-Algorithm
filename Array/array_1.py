# -*- coding: utf-8 -*-
"""Array-1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cJGFa9SenjP-_c4SmJ_8l9nynIJpUrDC

**Array Data Structure**

**Create an Array**
"""

import numpy as np
import array

#create an array using array module and numpy module
#start with array module

ar=array.array('i')
print(ar)

ar1=array.array("i",[1,2,3,4,5])
print(ar1)

"""
array module is more memory efficient than the list for storing
the large types of the same data type.

The only limitation is that it only support the basic
data types. So you cannot create an array by using the array
model with the custome data types or mixed data types.

so the arrays that are created by using the array model is going
to be homogeneous , which means that we will have only same
data type over here

"""

#ar2=array.array("i",[1,2,3,4,5,"m"])
#print(ar2)

#Let us use Numpy module

np_array=np.array([],dtype=int)
print(np_array)

np1_array=np.array([1,2,3,4])
print(np1_array)

"""
Advantage of numpy module is that it provides a feature
rich and high performance array object and it supports the
wide range of numerical operations and functions.

Disadvantage of that it is not part of the Python standard
library, so you have to install additional library to be
able to use it
"""

#Time and Space complexity of create an array with
#array module and numpy module

"""When we are creating an empty array with numpy and array
module the time complexity is constant.
which is O(1).

Because creating an empty array involves minimal operatins such
as initializing the array metadata and allocating a minimal
amount of memoery for the array elements.

So these operations take roughly the same amount of time,
ragardless of the array size and the space.

Space Complexity:-

Space complexity for creating an empty array is also constant
which is O(1).
because an empty array has no elements.

Therefore, the memory allocated for the elements is minimal or
none depending on the module used.

The memory used for array metadata is constant and does not depend
on the number of elements

Linear time complexity:-

Now, when it comes to creating an array with the elements in it,
the time complexity is linear with respect to the number of the
of the elements in the array, because the process of creating an
array with elements involves copyying the elements from the
input iterable.

np1_array=np.array([1,2,3,4])

In this case it is leased to the newly created array as the number
of elements increased , the time it takes to copy those elements
also increases proportionally.

Space complexity:-

Now when it comes to space complexiy, the space complexity is
also O(n) because the memory allocation for the array elements
depends on the number and the data type of the elements.

As the number of elements increased , the memory needed to store
those elements also increases proportinally.

In summary, the time and space complexity for creating the arrays
with element is O(N).

Because both the time taken to copy the elements and the memory
allocation for the elements depend on the number of the elements

For empty arrays, bot the time and space complexity are constant
since there are no elements to copy or allocate memory for.

**Insertion to Array**

->We can insert an element at the beginning of the array.

-> we can insert it int the middle of the array, or we can insert
it at the end of the array

"

Insert an element at the beginning of the array:-

Insert an element at the index 0.And all the element
will be shifted one step.

So, the index of one, which was zero before , is going to be one
in this case.

And all the index of the other elements will be increased by 1
because we are shifting the elements one step.

Insert an element in the middle:-

Same concept applies when adding an element in the middle of
the array.

Insert at the end of an array:-

Its going to insert the element at the end of the array with
new index. if the last index was 4 after inserting last index
will be 5

"
"""

ar1=array.array("i",[1,2,3,4,5])
print(ar1)

#Now use insert method.
# It takes 2 parameters. 1st for index and 2nd for value.

print("  ")


ar1.insert(0,6)

print("New element at index 1:- ")

print(ar1)

print(" ")

ar1.insert(2,7)

print("New element at index 2:- ")
print(ar1)

print(" ")

ar1.insert(7,8)

print("New element at last index :- ")
print(ar1)

"""Time Complexity:-

When we are inserting an element at a speicific position using
insert method, the time complexity depends on the number of
the elements that needs to be shifted right?

So in this case, it means that in the worst case, whe we are
inserting an element at the beginning of the array, the
time complexity will be O(N).

Space Complexity:-

Space complexity of inserting an element in an array using array
module is going to be O(1).

Because here when we are inserting the element , we need only
one place for that element.

**Traversal Operation**
"""

import array


arr1=array.array("i",[1,2,3,4,5,6])
print(arr1)

print(" ")

arr2=array.array("d",[1.3,1.5,1.6])
print(arr2)

#create traversal function

def traversalArray(array):

    for i in array:
        print(i)

traversalArray(arr1)

"""It starts from the 1st element, then goes toe next element
which is 2 then go to next element which is 3, then 4,5,6.

Its visiting each elements of this array and printing them
one by one

Time and Space Complexity of this operation:-

Time Complexity:-

1st line of code in our function is a for loop. we know from
our rules that looping through array is O(N) time complexity.

And the printing the element is constant time operation O(1).

So if we combine this 2 time complexities:O(N) + O(1).
we can easily see that non-dominant term here is O(1).

So the time complexity :- O(N).

Space Complexity:-

Space complexity for this menthod is constant because we don't
need an extra location to perform this operation.

Space complexity:- O(1).

**Accessing an element of an array**
"""

# write an algorithm to access element of an array.

array_1=array.array("i",[1,2,3,4,5,6])
print(array_1)


print(" ")

def accessElement(array,index):

    #write a condition to prevent the case is that if the
    #index does not exist in this array.
    #>= means it will include last index. otherwise it will show
    # array index out of range error.
    if index>=len(array):
        print("Element does not exist in an  array")

    else:
        print(array[index])

accessElement(array_1,1)

print(" ")

print("New example")

accessElement(array_1,3)

"""Time Complexity:-

1st line of code is condition. based on rules, conditions take
constant time complexity=O(1).

2nd line of code. print statement. constant time complexity=O(1).

3rd line of code. else statement.we have print statement. we put
inside array directly the index that's why this also constant
oopeations because we are not iterating through an array.

we are just giving the exact address of the element over here.
which is hte best characteristic of array to access directly
to the element based on the index.

SO it is constant time operation.

total:- O(1)+O(1)+O(1)=O(1)

Space complexity:-

the space complexity of this function will be same because we
do not need extra space here to perform this operation.

**Searching for an element in Array**

Searching for an element in an array can be perfomed using
Linear Search Algorithm.

In Linear Search, you can iterate throgh tht element of the
array one by one , comparing each element with the target value.

If the target value is found, the search is successful and you
can go ahead and return the index of the target value.

If the target value is not found after iterating all elememts,
the search is unsuccessful and you can return an indication that
value was not found.
"""

array_1=array.array("i",[1,2,3,4,5,6,7,8])
print(array_1)

def linear_search(array,target):

    for i in range(len(array)):

        if array[i]==target:
            return i

    return -1


print(linear_search(array_1,8))

print(" ")

print(linear_search(array_1,9))

"""Time complexity:-

1st line of code is for loop. THis is going to take O(N) time
complexity because the loop iterates over n element where n is
the length of the array.

2nd line of code is if condition.we know that if condition takes
O(1) time complexity

3rd line of code is return operation and it is also constant
time complexity O(1).

4th line of code is return -1.This one will also take constant
time complexity O(1).

total = O(N)+O(1)+O(1)+O(1)=O(N).
After combining all time complexities.we can see that
time complexity for Linear Search is going to be O(N).

Time complexity of len function is O(1) as it is the constant
time operation that retrieves stored len value of the array object
So that's why it is called once.

It does not impact overall time complexity of the linaer seach
function and the range function use to create a range object
representing a sequence of integers from zero up to but not
including the length of the input array.

The time complexity of creating the range object is O(1) as it
does not generate the actual sequence of the integers but
rather creates an iterator that can be used to produce number on
demand.

Space Complexity:-

It is going to be O(1) because it does not required
additional memory to perform this opertaion

**Deleting an element from an Array**

Move all elements after deleting a value.

Deletion is very efficient when we remove last element.

Otherwise deletion becomes time consuming.
"""

array_1=array.array("i",[1,2,3,4,5,6,7,8])
print(array_1)

print(" ")

array_1.remove(1)
print(array_1)

print(" ")

array_1.remove(5)
print(array_1)

print(" ")

array_1.remove(8)
print(array_1)

"""Time Complexity:-

If we remove the last element from the array. The time complxity
will be O(1). Because we are just directly connecting to last
element and removing it.

If we remove element from middle of the array the time complexity
will be O(N), because after removing that element, we need to
mofe all the remaining elements to one step left.

SO in worst case it will take O(N) time complexity.

Space Complexity:-

we don't need extra space for performing this operation so space
complexity will be O(1).

**Two - Dimensional Array**

**Create 2-D Array**

Use temprature example:-

Day 1 - 11,15,10,6
Day 2 - 10,14,11,5
Day 3 - 12,17,12,8
Day 4 - 15,18,14,9

Here instead of array module we will use numpy module
because it works perfectly with multi dimensional arrays.

"
"""

import numpy as np

two_D_array=np.array([[11,15,10,6], #1st row
                      [10,14,11,5], #2nd row
                      [12,17,12,8], #3rd row
                      [15,18,14,9]]) #4th row

two_D_array

"""Time complexity:-

Time complexity to create an 2D array will be O(MN).
where M=No. of columns
      N=No. of rows

this is very time consuming operation. we are initializing the
value straight away.

Space Complexity:-

Space complexity for this operation is O(NM). because we have
M number of columns and N number of rows.

So we need this number of space in the memory.

**Insertion - 2D Array**
"""

import numpy as np

two_D_array=np.array([[11,15,10,6], #1st row
                      [10,14,11,5], #2nd row
                      [12,17,12,8], #3rd row
                      [15,18,14,9]]) #4th row

two_D_array

"""
We will use insert function of arrays to insert a new row or column
to 2D array.
"""

new_twod_array=np.insert(two_D_array,0,[[8,8,8,8]],axis=1)

#(array,index,values,axis=1 is column 0 is for row)

new_twod_array

new_twod_array=np.insert(two_D_array,0,[[13,13,13,13]],axis=0)

#(array,index,values,axis=1 is column 0 is for row)

new_twod_array

new_twod_array=np.append(two_D_array,[[13,13,13,13]],axis=0)

#append will add value at the end directly.


new_twod_array

new_twod_array=np.append(two_D_array,[[14,14,14,14]])

#append will add value at the end directly.


new_twod_array

"""**Access an element of 2D Array**"""

import numpy as np

two_D_array=np.array([[11,15,10,6], #1st row
                      [10,14,11,5], #2nd row
                      [12,17,12,8], #3rd row
                      [15,18,14,9]]) #4th row

two_D_array

# Create a function which access element of 2D array.

def access(array,rowIndex,columnIndex):

    if rowIndex>=len(array) or  columnIndex>=len(array[0]):

        #or is must in condition. and will give and error.
        #len(array) will count No. of rows.
        #len(array[0]) wil count No. of columns.

        print("Incorrect Index")

    else:
        print(array[rowIndex][columnIndex])

print(access(two_D_array,2,1))

print("  ")


print(access(two_D_array,2,5))

"""Time complexity:-

1st line of code. we have if condition which is checking the number
of rows and number of columns in array.So time complexity will be
O(1).

2nd line of code. printing message.time complexity will be O(1).

3rd line of code. else condition. which is printing the value of a
cell in 2D array.time complexity will be O(1).

total= O(1)+O(1)+O(1)=O(1) time complexity.

Space complexity:-

Space complexity is O(1) because we don't need any extra space to
perform this operation.

**Traversal 2D Array**
"""

import numpy as np

two_D_array=np.array([[11,15,10,6], #1st row
                      [10,14,11,5], #2nd row
                      [12,17,12,8], #3rd row
                      [15,18,14,9]]) #4th row

two_D_array

# create a new function to traverse through an array

def traverseArray(array):

    for i in range(len(array)): #calculate length of row
        for j in range(len(array[0])): #calculate length of column
            print(array[i][j])


traversalArray(two_D_array)

"""Time complexity:-

if we have nested loop in function then time complexity is the
quadratic time complexity.

But here if the number of rows equals to the number of columns, then
we have quadratic time complexity otherwise we will have
O(MN) time complexity which will be the M= No. of columns
N= No. of rows

1st line of code. for loop for rows. time complexity will be O(MN).
M: No. of columns and N: No. of rows.
Because for each row we have to traverse through all columns.
so this means that if number of rows is M and number of columns is N
and so the time complexity will be O(MN). if M=N then the time
complexity will be quadratic time complexity O(N^2)

2nd line of code. for loop for columns. time complexity will be O(N).
which will be the number of columns N

print statement take constant time complexity O(1).

Space Complexity:-

Space complexity will be O(1) because we don't need any extra space
for perfoming this operation

**Searching for an element in 2D array**
"""

import numpy as np

two_D_array=np.array([[11,15,10,6], #1st row
                      [10,14,11,5], #2nd row
                      [12,17,12,8], #3rd row
                      [15,18,14,9]]) #4th row

two_D_array

#create a linear search function

def search_two_D_array(array,target):

    for i in range(len(array)):
        for j in range(len(array[0])):

            if array[i][j]==target:
                return "The value is located at index " +"row:- "+str(i)+" & "+"column:- "+str(j)

    return "Element not found"

print(search_two_D_array(two_D_array,10))

print(" ")

print(search_two_D_array(two_D_array,20))

"""Time complexity:-


1st line code. for loop for rows. this will be O(MN) time complexity.
even though we are looking inside same array.The no. of columns and no. of
rows might be different.

In this case if we have the No. of rows=No. of columns then this will have
quadratic time complexity O(N^2). otherwise it will be O(MN).

for this function we have no. of rows=no. of columns so time complexity will be
O(N^2).


2nd line code.for loop for column.this will take O(N) time complexity.
where N is the No. of columns


3rd line  code. if condition.Time complexity of if condition is O(1).
And accessing an element of any given array is O(1) time complexity


Space Complexity:-


Space complexity will be O(1) because we don't need any extra space
for perfoming this operation

**Deletion 2D Array**
"""

import numpy as np

two_D_array=np.array([[11,15,10,6], #1st row
                      [10,14,11,5], #2nd row
                      [12,17,12,8], #3rd row
                      [15,18,14,9]]) #4th row

two_D_array

new_two_D_array=np.delete(two_D_array,0,axis=0)
new_two_D_array

#np.delete(array,index, axis=0 for row and axis=1 for column)

new_two_D_array=np.delete(two_D_array,0,axis=1)
new_two_D_array

"""# Array-1 Practice

# 1. Create an array and traverse.
"""

from array import *

import numpy as np
arr=array("i",[1,2,3,4,5])

for i in arr:
    print(i)

"""# 2. Access individual element through indxes"""

print(arr[0])

print(" ")

print(arr[2])

"""
# 3. Append any value to the array using append() method

"""

arr.append(6)
print(arr)

"""# 4. Insert value in an array using insert() method"""

arr.insert(3,10)
print(arr)

"""# 5. Extend python array using extend() method"""

arr=array("i",[1,2,3,4,5])

arr1=array("i",[6,7,8,9,10])

arr.extend(arr1)
print(arr)

"""# 6. Add items from list into array using fromlist() method"""

arr=array("i",[1,2,3,4,5])

ls=[10,20,30,40]

arr.fromlist(ls)
print(arr)

"""
# 7. Remove any array element using remove() method"""

arr.remove(1)
print(arr) #remove the value 1

"""# 8. Remove last array element using pop() method"""

arr=array("i",[1,2,3,4,5])

arr.pop()
print(arr)

"""# 9. Fetch any element through its index using index() method"""

arr=array("i",[1,2,3,4,5])

arr.index(4)

"""# 10. Reverse a python array using reverse() method"""

arr=array("i",[1,2,3,4,5])
arr.reverse()
print(arr)

"""# 11. Get array buffer information through buffer_info() method"""

arr=array("i",[1,2,3,4,5])
arr.buffer_info()

# buffer_info() returns a tuple, which contains the memory
# address and the length of the buffer that holds the arrayâ€™s
# contents in the form (address, length)."

"""# 12. Check for number of occurrences of an element using count() method"""

arr=array("i",[1,2,3,4,5,3,5,1,2,6,7,3,6,8,9,19])

print(arr.count(2))

"""
# 13. Convert array to string using tostring() method"""

arr=array("i",[1,2,3,4,5])

new_arr=arr.tobytes()

print(new_arr)
print(" ")
"""
Hypothesis
It appears that you are trying to convert the array arr to a
string using the tostring() method.
 However, the correct method name is tobytes().
 The tostring() method was deprecated in Python 3.2 and has been removed."""

print( " ")

ls=list(arr)

new_str=" ".join(str(x) for x in ls)
print(new_str)