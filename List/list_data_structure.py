# -*- coding: utf-8 -*-
"""List Data Structure.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-fR9NW1B9j7SUQ4vc79Qyew05PWSuc0m

# Create a List
"""

integers = [1,2,3,4,5]
print(integers)

string_list=['mrugesh','malav','maya','minaxi']
string_list

mix_list = [1,2,3,1.5,2.5,'Mrugesh']
mix_list

nested_list = [1,2,3,[1.5,2.5],['Mrugesh','Maya']]
nested_list

"""# Accessing / Traversing List"""

shopping_list= ['Milk','Cheese','Paneer','Butter']

shopping_list

#Access the element

# 1st element of the list

print(shopping_list[0])


# 2nd element of the list

print(shopping_list[1])

# Think list as a relationship between indexes and elements
# This relationship is called mapping

# Each index maps to the one of the elements.
# List index work the same as array indexes.

# Any integer expression can be used as index.
# For example, if we try to read or write an element that does not
# exist, we will get an error.

#print(shopping_list[4])

#  IndexError: list index out of range

# In operator

# By using IN operator , we can find out if an element exists in this list
# or not.

print("Milk" in shopping_list)

print("Bread" in shopping_list)

# if provided index is minus then we are trying to access
# element from backward

shopping_list= ['Milk','Cheese','Paneer','Butter']
print(shopping_list[-1])

print(shopping_list[-2])


#print(shopping_list[-5])
#IndexError: list index out of range

"""
Traverse through the List:-

The most common way to traverse the elements of a list is with Loop.
"""
for i in shopping_list:
    print(i)

# len() function
# len() function is returning the value of a number of items in a container

# range() function
# range() functiin saves us from index error because it works from 0 to N-1
# which means if that if we put 3 then it will go till 2.


for i in range(len(shopping_list)):

    shopping_list[i] = shopping_list[i] + " + "
    print(shopping_list[i])

# we can traverse through empty list but code will print nothing
#

empty_list=[]

for i in empty_list:
    print(i)
    print("No items")

"""# Update / Insert List

List are mutable data structures.

That's why we can change the order of elements in a list or reassign an
item in a list.

When the bracket operator appears on the left side of an assignment,
it identifies the element of the list will be assigned.
Ex:- mylist[index]=1
"""

myList = [1,2,3,4,5,6,7]
myList

"""
List are ordered collections, meaning that the order of  elements will
be the same order as we declare them till we change the order.

To Update an element in the list we need to access the element and then
assign a value to it

"""

myList[2] = 333
print(myList)

myList[4] = 555
print(myList)

"""Time Complexity:-

So the Time Complexity of this operation is O(1) because we know that
accessing an element of a list is O(1) time complexity.
we are just assigning a value in this operation.


This is the most beneficial part of list, because list provides us
very efficient way of accessing elements by using their index and index
identifies their locations in the memory.

Space Complexity:-

Spacy Complexity for updating an element in a list is O(1).
Because we don't need an extra memory.
we have already reserved the memoery for a given element.
we are just changing the value of it.
This means that an extra memory is not required.

Insertion Operation:-

There are 4 ways of inserting a value to a list.

1.) Inserting an element to the beginning of the list

2.) Inersting an element to the any given place in the list

3.) Inserting an element to the end ot the list

4.) Inserting another list the to the list.

To perform these opertions we will use these List methods
-> insert()
-> append()
-> extend()

""
"""

myList = [1,2,3,4,5,6,7]
myList

# insert() method

# The insert method inserts an elemtn in any given location to the list
# we can use insert method to insert an element at the beginning of
# the list or any given location in list.
# insert(index,value)

myList.insert(0,111)
print(myList)


myList.insert(4,44)
myList

# append() method

# append() method will add an element at the end of list.

myList = [1,2,3,4,5,6,7]

myList.append(888)
print(myList)

# extend() method

# extend() method will add another list to our list

myList = [1,2,3,4,5,6,7]
print(myList)

new_list=[555,777,888]

myList.extend(new_list)
print(myList)

"""Time Complexity:-

Adding an element using insert method , we have to move all elements
one step right.
So this means that the time complexity will be O(N) for this method.

Append method just an element at the end of list. This means that
this is very efficient we are not moving in elements.
So the time complexity for this method is O(1).

Extend method with extend the time complexity depend on the elements
of the list.
This means that if we have N nunmber of elements then time complexity
for an extending to a new lust will be O(N).
Because the way it workd in just looping throught all elements of the
new list and adding them 1 by 1 at the end of the list that we want
to add.

Space complexity:-

Space complexity is O(1) because we just need 1 location for each
element

Space complexity for extend method is O(N) because it depends on the
number of elements, how many elements that we are going to add
if we had N number of elements.

So we need to allocate N number of elements so the space complexity
for the extend method will be O(N)

# Slice /  Delete from a list
"""

# For slicing we use slicing operator [:].

myList = ['a','b','c','d','e','f']
print(myList)

# Print 1st 2 elements

print(myList[0:2])

print(myList[:2])

# print without 1st element.

print(myList[1:])

# print all elements

print(myList[:])

# Update 1st 2 elements in list

myList[0:2] = ['M',"J"]
print(myList)

"""
Deletion:-

There are several different ways of deleting an element from a list.

pop()
delete()
remove()

"""

# pop() method

# we need to provide an index of element when using pop() method
# pop methods takes as parameter index of the element that we
# want to delete.
# if we do not provide any index then pop method will remove the last
# element in the list.


print(myList)

#remove 2nd element
myList.pop(1)

print(myList)

print(myList.pop())

# delete() method

# If we don't need removed values, we can use delete method
# delete method also works on index

myList = ['M', 'J', 'c', 'd', 'e', 'f']

del myList[1]
print(myList)


del myList[2]
print(myList)

myList = ['M', 'J', 'c', 'd', 'e', 'f']
del myList[2:4]
print(myList)

# remove() method

# remove method is very useful when we know the element itself.
# we don't need to know the index.
# we can just provide the value and delete that value.

myList = ['M', 'J', 'c', 'd', 'e', 'f']

myList.remove('M')
print(myList)

myList.remove('f')
print(myList)

"""Time Complexity:-


To remove an element using pop method. If we don't use it without
any parameter it will just remove last  element.
This means that time complexity O(1) because deleting last element
is not causing any shift in our list.

If we use pop function to delete an element from the beginning from
the list, then the time complexity will be O(N), because if we
delete 1st element , the reset elements have to move 1 step left.
This means this will take too much tome if we have more values.

delete method also takes O(N) time complexity because here when we
delete any specified element or multiple elements the rest elements
have to move 1 stepe to the left.


remove method also takes O(N) time complexity because here we are
providing the element straight away, which means that if  we provide
1st element or elements others will have to 1 step to the left.




Space Complexity:-

Space complexity for all methods wil be O(1)  because there more
requiremens for extra memory to perform any deletion

# Searching for an element in a List
"""

my_list = []

for i in range(10,100,10):
    my_list.append(i)

print(my_list)

"""
There are 2 ways of searching an element in the list.

1.) Using in operator
2.) Liner search

"""

# in operator

target = 50

if target in my_list:
    print(f"{target} is in {my_list}")

print(" ")

target = 500

if target in my_list:
    print(f"{target} is in {my_list}")
else:
    print(f"{target} is not in the {my_list}")

"""Time Complexity:-

When using in operator in Python the time complexity is O(N).
In the worst case, where n is the number of elements in the list,
this is because under the hood Python performs a linear search
to check if an element is present in the list or not.

keep in mind that in operator has better time complexity when used
with sets and dictionary which are implemented as hash tabel.

Linear search

we are going to search for an element in the list, checking each
element 1 by 1

we are going to start from the beginning from  the list.
check if the current value is equal to the target value or not.

if it is equal , it is successful. it will return the index
of target value.

if it is not , will move the next element and checking for the
target value.

So these steps will repeat until we reach the last element in the list.


"
"""

# enumerate :- to get pairs for the index and values from the list.
# this function iterate over the list while also keeping the track
# of the index of the current item.


def linear_search(my_list,target_value):

    for i,value in enumerate(my_list):
        if value == target_value:
            return i

    return -1


my_list = []

for i in range(10,100,10):
    my_list.append(i)

print(my_list)

linear_search(my_list,40)

linear_search(my_list,110)

"""Time Complexity:-

1st line:- for loop
which is looping through the all elements of the list with enumerate
function.
In this case time complexity will be O(N) because enumerate function
keeps the track of the current item.

2nd line:- value==target_value
time complexity will be O(1). because we are just comparing with
target value.

3rd line:- return 1
time complexity will be O(1).

4th line:- return -1
time complexity will be O(1).

Now, if we combine all these time complexities together

total time complexity = O(N) + O(1) + O(1) + O(1) = O(N)

Space complexity:-

Space complexity of Linear search will be O(1) because in this case
an extra memory is not required to perform this operation.

# List Operations /  Functions

**List Operations**
"""

# The 1st operation is ' + ' operator, which concatenates the lists,


a = [1,2,3]
b = ['a','b','c']

c = a + b
print(c)

# The 2nd operator is ' * ' operator.
# by using this operator any element in the list can be repititive.


a = [100]
a = a * 4
print(a)

print(" ")

b = [100,200]
b = b * 4
print(b)

"""**List Functions**

1.) len() :- To count the elements of the list.

2.) max() :- Returns the item with the highest value in the List

3.) min() :- Returns the item with the lowest value in the list

4.) sum() :- Returns the sum of all items in the list
"
"""

# len()

a = [1,2,3,4,5,6,7]
print(len(a))

# max()

a = [1,2,3,4,5,6,7]
print(max(a))

# min()

a = [1,2,3,4,5,6,7]
print(min(a))

# sum()

a = [1,2,3,4,5,6,7,8,9,10]
print(sum(a))

# Average value

a = [1,2,3,4,5,6,7,8,9,10]
print(sum(a)/len(a))

# Average function

total = 0
count = 0

while(True):

    input_value = input("Enter a number :- ")

    if input_value == 'done': break

    value = float(input_value)

    total = total + value

    count = count + 1

    average = total/count

print("Average: ", average)

my_list = list()

while(True):

    input_value = input("Enter a number :- ")

    if input_value == 'done': break

    value = float(input_value)

    my_list.append(value)


if len(my_list) > 0:

    average =  sum(my_list) / len(my_list)

    print("Average :- ",average)

else:
    print("No values entered")

"""# List and Strings

"""

# String is sequence of characters

# List is sequence of values

# List of character is not the same as string

# To convert a string to a list character, we can use list function

a = 'Malav'
print(a)

b = list(a)
print(b)

# .split() method

a = 'Mrugesh Malav Maya'
print(a)

b = a.split( )
print(b)

print(" ")

a = 'Mrugesh-Malav-Maya'
print(a)

b = a.split('-') #delimiter = '-'
print(b)


print(" ")

a = 'Mrugesh-Malav-Maya'
print(a)

b = a.split('a') #delimiter = '-'
print(b)

# .joint() method

# convert list to string


a = 'Mrugesh-Malav-Maya'
print(a)

print(" ")

b = a.split('a') #delimiter = '-'
print(b)

print(" ")

c = 'a'.join(b)
print(c)

"""# Common List pitfalls and ways to avoid them"""

# carless use of list can waste time in debugging.

# The 1st is we don't need to forget that most list methods modify
# the argument and return none.

# This is the opposite of string methods which returns a new stribg
# and leave the original alone.

my_list = [2,4,3,5,8,7]

my_list = my_list.sort()
print(my_list)

# The 2nd one is that there are many ways to do things

# For example, to remove an element form the list you can use
# pop method, remove method and deleted method or even a slice
# assignement can be used to remove the elements.

# This can lead to miunderstanding.

# The 3rd problem is whenever we do any operation on list, we
# need to take a copy of this list.

# Because many methods modifying original list itself without
# keeping the original one.

my_list = [2,3,4,5,9,8,4]
print(my_list)
my_list.sort()
print(my_list)

# so we can see that it modified original list.

# so the best way to avoid such problem is to create a copy of
# a list.

# we can also use sorted function

print(" ")

my_list = [2,3,4,5,9,8,4]
print(sorted(my_list))
print(my_list)

"""# List vs. Array

Similarities between List and Array: -

1.) Both data structures are mutable.
It means that we can update elements of both data structures.
So by using their index, we can update any element in the list or
in the array.

2.) Both can be indexed and iterated through.
This means that we can access the elements by using their index and
we can iterate through them.


3.) They can be both sliced.
By using slice personality we can slice both list and arrays.

Difference between List and Arrya: -

1.) The main difference between these two data structure is the
operation we perform on them.

Array are specially optimized for arithmetic computations. So if we
try to perform similar operations, we should consider using array
instead of list.

2.) The 2nd main difference is that in list the elements data types
can be different , but in array all elements has to be same data type.
"""

# for 1st difference

import numpy as np

my_array = np.array([1,2,3,4,5,6])

my_list = [1,2,3,4,5,6]

print(my_array/2)

# print(my_list/2)
# error:- TypeError: unsupported operand type(s) for /: 'list' and 'int'

import numpy as np

my_array = np.array([1,2,3,4,5,'a'])

my_list = [1,2,3,4,5,6,'a']

print(my_array)
# all array elements are printed as string even though we declared
# as integer it converted in string.

print(my_list)
# in case of list it remained the same.

"""# Time and Space Complexity of List

1.) Creating an empty list

Time complexity :- O(1)
Space complexity :- O(1)

2.) Creating a List with elements

Time Complexity :- O(N)
Space complexity :- O(N)

3.) Inserting a value in a list

Time Complexity :- O(N)
Space Complexity :- O(1)

4.) Traversing a List

Time Complexity :- O(N)
Space Complexity :- O(1)

5.) Accessing a given cell in List

Time Complexity :- O(1)
Space Complexity :- O(1)

6.) Searching a given value in List

Time Complexity :- O(N)
Space Complexity :- O(1)

7.) Deleting a value from List

Time Complexity :- O(1)
Space Complexity :- O(1)



"

# List Comprehension

Only Python has an option of List Comprehension

other programming language does not have this functionality.
It cuts down the amount of typing and make code shorter
and makes it lot easier to read.

What is List Comprehension?

It is a case where you create a new list from the previous list.
So far we are creating a list from other lists using for loops.

syntax = [ expression:operation  for loop]
"""

# Traditional way of creating a new list


my_list = [1,2,3]
print(my_list)
print(" ")
new_list =[]

for i in my_list:
    new = i*2
    new_list.append(new)

print(new_list)

# using list comprehension

my_list = [1,2,3]
print(my_list)
print(" ")

new_list = [item*2  for item in my_list]
print(new_list)

ls = "Mrugesh"

new_ls = [i for i in ls]
new_ls

"""# Conditional List Comprehension

"""

# new_list = [ new_item for item in list if condition]

my_list = [-1,10,20,2,-90,-100,45,88,32,-32]

print(my_list)
print(" ")

new_list = [ i for i in my_list if i>0]
print(new_list)

print(" ")
new_list_negative= [i*i for i in my_list if i<0]
print(new_list_negative)

sentence = 'My father name is Mrugesh Joshi'

def is_constant(letter):
    vowels = 'aeiou'
    return letter.isalpha() and letter.lower() not in vowels

print(is_constant('a')) # a is vowels so printed False

print(is_constant("M")) # M is constant so printed True

print(" ")
constants = [ i for i in sentence  if is_constant(i)]

print(constants)

my_list = [-1,10,20,2,-90,-100,45,88,32,-32]
print(my_list)

print(" ")

new_list = [i if i>0 else 0 for i in my_list ]

print(new_list)


print(" ")

new_list = [i if i>0 else '- value' for i in my_list ]

print(new_list)

my_list = [-1,10,20,2,-90,-100,45,88,32,-32]

def number(number):
    return number if number>0 else "Negative value"

print(my_list)
print(" ")

new_list = [number(i) for i in my_list]
print(new_list)