# -*- coding: utf-8 -*-
"""Tuple Data Structure.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kvs-lgeBNwQmmwinoGk6DEJ1psdhiE9S

# Tuple

A tuple is a sequence of values much like a list.

The value stored in tuple can be any type and they are indexed
by integers.

The important differnce is that tuples are immutable, which means
that when tuple is declared it cannnot be changed.

Tuple are also comparable and habshable , so we can sort list of
them and use tuples as key values in Python Dictionary.

What is hashable?

An object is set to be hashable if it has a value that remaind the same
during its liftime

"
"""

tup = ('a','b','c','d','e')
print(tup)

print(" ")

tup_1 = ("a",)

# if we don't add comma after value it will just print
# a letter a
print(tup_1)

print(" ")

"""Time Complexity for creating a tuple is O(1).

because here we are defining all elements up front.

Space complexity for creating a tuple is O(n)

Because this depends on the number of elements of the tuple.
So, if we have n elements in the tuple, the space complexity will be
O(n)

# Tuples in Memory/ Accessing an element of Tuple
"""

tup = ("a","b","c","d","e")
print(tup)

# Tuple elements are located in memory contiguosly.
# So index is used to access them.

print(tup[0])

print(tup[3])


print(tup[-3])

# Access element using slice[:] operator

tup = ("a","b","c","d","e")
print(tup)

print(tup[1:])

print(tup[2:4])

print(tup[:])

"""# Traversing through Tuple"""

tup = ("a","b","c","d","e")

for i in tup:
    print(i)

for i in range(len(tup)):
    print(i , tup[i])

"""Time Complexity :-

The Time Complexity for traversing thorugh a tuple is O(n).
Because here we visit each and every element of tuple and printing them.

Space Complxity :-

Space Complexity will be O(1) because for traversing tuples an
additional memory is not required.

# Searching for an element in Tuple
"""

"""

There are various way of searching for an element in tuple.

The 1st method is using of IN operator.

"""


tup = ("a","b","c","d","e")

print("a" in tup)

print("m" in tup)


"""
The Time Complexity for this method will be O(n)
Because IN operator work as a linear search and its search
for element one by one.

"""

"""

The 2nd method is Index method

"""
tup = ("a","b","c","d","e")

print(tup.index("d"))


print(tup.index("b"))

#If an element is not in tuple.It will give value error.

#ValueError: tuple.index(x): x not in tuple

"""
The Time Complexity for this method will be O(n)
Because index method work as a linear search and its search
for element one by one.

"""

"""

Now the last method is custom way so we can search through the
new tuple and find out element in the tuple.

Now the difference from the index method is that in this case
we can put a custom message and get the result in proper way.

"""

tup = ("a","b","c","d","e")

def search_tup(tup_1,element):
    for i in range(0,len(tup_1)):

        if tup_1[i] ==element:
            return f"The {element} found at {i} index"

    return "Element not found"

print(search_tup(tup,"d"))

print(" ")

print(search_tup(tup,"m"))

"""

Time Complexity : -

return "Element not found" --> O(1)

return f"The {element} found at {i} index" --> O(1)

if tup_1[i] ==element: --> O(1)

for i in range(0,len(tup_1)): --> O(n)

Total Time Complexity : - O(1) + O(1) + O(1) + O(n) = O(n)


Space Complexity: -

Space Complexity will be O(1) because in this case we run
this function an extra memory not required.

"""

"""# Tuple Operations/ Functions"""

tup_1 =(1,4,3,2,5,11,15,20,23)

tup_2 =(2,4,1,6,8,9,14,17,19)

print(tup_1,tup_2)

# Concatenation operator

tup_3 =  tup_1 + tup_2
print(tup_3)

# * operator
# * operator can be used with integer
# each element will be repeated n times.


print(tup_1*2)

"""

Method that add and remove the items from tuple are
not available because tuples are immutable.

"""

# Count method

# count repetition of element in tuple

tup_1 =(1,4,3,2,5,5,5,2,4,5,1,3,3,6,11,15,20,23)


print(tup_1.count(1))

print(tup_1.count(2))

print(tup_1.count(5))

# len() function

# Return the number of elements in tuple

tup_1 =(1,4,3,2,5,5,5,2,4,5,1,3,3,6,11,15,20,23)

print(len(tup_1))

# max() function

# It will return maximum number in the tuple.

print(max(tup_1))


print(max(tup_2))

# minimum() function

# It will return minimum number in the tuple.

print(min(tup_1))


print(min(tup_2))

"""# Tuple vs. List"""

# List is mutable , whereas a tuple is immutable.


ls = [1,2,4,5,6,7]

print(ls)

ls[1] = 20
print(ls)

# delete element

print(ls)
del ls[0]

print(ls)

# Do same operations as above on Tuple

tup = (1,2,3,4,5,6)
print(tup)

#tup[1]=20
#print(tup)

# TypeError: 'tuple' object does not support item assignment

# delete element

#del tup[0]
# TypeError: 'tuple' object doesn't support item deletion

# we cannot delete single element but we can delete entire tuple

tup = (1,2,3,4,5,6)
print(tup)

del tup

"""Functions can be used for both List and Tuple:-

len()
max()
min()
sum()
all()
sorted()

Methods cannot be used for Tuples:-

append()
insert()
remove()
pop()
clear()
sort()
reverse()

Tuples can be stored in Lists
Lists can be stored in Tuples

Both Lists and Tuples can be nested

1.) we generally use tuples for heterogeneous (different)
data types and lists for homogeneous(similar) data types

2.) Iterating through a tupls is faster than with list

3.) Tuples that contain immutable elements can be used
as a key for dictionary

4.) If data that does not change, implementing it as tuple
will guarantee that it remains write protected.

1.) Creating a Tuple

Time Complexity:- O(1)
Space Complexity:- O(n)

2.) Traversing a given Tuple

Time Complexity:- O(n)
Space Complexity:- O(1)

3.) Accessing a given element

Time Complexity:- O(1)
Space Complexity:- O(1)

4.) Searching a given element

Time Complexity:- O(n)
Space Complexity:- O(1)
"""





