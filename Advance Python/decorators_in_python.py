# -*- coding: utf-8 -*-
"""Decorators in Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qxjom5YmDDRjd3KPteejrP6zpprj3Hl6

# Decorators

A decorator in Python is a design pattern that allows you to modify or enhance the behavior of a function or method without changing its actual code. In simple terms, a decorator is a function that "wraps" another function to extend or alter its behavior.

**Decorators are commonly used for:**

Logging

Authorization/authentication

Caching/memoization

Timing functions (e.g., measuring execution time)

Validating inputs, etc.

**How Decorators Work**

A decorator is essentially a higher-order function: it takes a function as an argument, modifies it (typically by adding new behavior), and returns a new function.
"""

# Function Copy

def welcome():
    return "Welcome to the Maya Villa."

wel= welcome
print(wel())

del welcome

wel()

# so even though welcome is removed we can still print string

"""#Closures in Python

A closure in Python refers to a function that "remembers" the environment in which it was created, even after the outer function has finished executing.

Specifically, closures allow a function to capture and retain access to variables from its enclosing (outer) function, even when the outer function has returned.

Closures are a powerful feature in Python that can be used to create functions with persistent state, or to implement concepts like decorators.

**How Closures Work**

You define a function inside another function (the "enclosing" function).


The inner function (the "nested" function) references variables from the outer function.


The inner function is returned by the outer function.


Even after the outer function has finished execution, the inner function still retains access to the outer function's variables.

"""

# Closures

def main_welcome():
    msg="Welcom to the Maya Villa."

    def sub_welcome():
        print("Welcom to the Mrugesh Villa.")

        print("Hard work pays off.")

    return sub_welcome()

main_welcome()

def main_welcome():
    msg="Welcom to the Maya Villa."

    def sub_welcome():
        print("Welcom to the Mrugesh Villa.")
        print(msg)
        print("Hard work pays off.")

    return sub_welcome()

main_welcome()

# func as print method

def main_welcome(func):

    def sub_welcome():
        print("Welcom to the Mrugesh Villa.")
        func("Welcom Home.")
        print("Hard work pays off.")

    return sub_welcome()

main_welcome(print)

# length of list

def main_welcome(func,lst):

    def sub_welcome():
        print("Welcome to the Maya Villa.")
        print(func(lst))
        print("Welcome to the Mrugesh Villa.")

    return sub_welcome()

main_welcome(len,[1,2,3,4,5])

# Decorator


def main_welcome(func):

    def sub_welcome():
        print("Welcome to the Maya Villa.")
        func()
        print("Welcome to the Mrugesh Villa.")

    return sub_welcome()

def new_method():
    print("Welcome to TD Insurance.")

new_method()

main_welcome(new_method)

# lets try to print all messages without using main_welcome

# create a decorator

@main_welcome
def new_method():

    print("Welcome to TD Insurance.")