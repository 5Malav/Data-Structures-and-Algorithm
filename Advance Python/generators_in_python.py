# -*- coding: utf-8 -*-
"""Generators in Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_GctpQ32W7Kt8RJmRZM26V30PkJaD8yz

# Generators

->Generators are a special type of iterator that allow you to iterate over data without storing the entire sequence in memory at once.

->Generators are a more memory-efficient alternative to creating lists or other collections, especially when working with large datasets or infinite sequences.

-> Generators are a simpler way to create interators. They use the **yield** keyword to produce a series of lazily, which means they generate values on the fly and do not store them in memory.


**Key Features of Generators:**

Lazy Evaluation: Generators produce values one at a time as you iterate over them, rather than generating all values upfront. This makes them more memory efficient for large sequences.


State Retention: A generator function retains its state between iterations, allowing it to "pause" and "resume" execution when yield is used.
"""

def square(n):
    for i in range(3):
        return i**2

square(3)

# it gives 0 because it iterates through all elements and 1st element is 0.

def square(n):
    for i in range(3):
        yield i**2

square(3)

# it is converted into generator object.

for i in square(3):
    print(i)

# with next method

a = square(3)
a

next(a)

next(a)

next(a)

#next(a) StopIteration:

def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()
gen

next(gen)

next(gen)

next(gen)

gen = my_generator()
gen

for val in gen:
    print(val)

# Leading Large files

# Generators are particulary useful for reading large files because they allow you
# to process one line a time without loading the entire file into memory.