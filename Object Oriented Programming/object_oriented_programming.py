# -*- coding: utf-8 -*-
"""Object_Oriented_Programming.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19mpNiAJrx1rwGYPZC0G_Uf8t8POSLA9p

# Class and Objects

->Object-Oriented Programming (OOP) is a programming paradigm that uses "Object" to design applications and computer programms.

->OOP allows for modeling real-world scenarios using classes and objects.

->A class is a user defined blueprint or prototype from which objects are created.

->Classes provide a means of budling data and functionally together. Creating a new class creates a new type of object, allowing new instance of that type to be made.

->Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by their class) for modifying their state.

->An object is an instance of a class. It is create based on the structure defined in the class and can use the methods and access the attributes of that class.
"""

# A class is blue print for creating objects, attributes and methods.

class Car:
    pass

# object instantiation

audi = Car()
bmw = Car()

print(type(audi))

print(audi)
print(bmw)

# Attribute
audi.windows=4
print(audi.windows)

# this is not a proper way to define attribute....

dir(audi)

"""
A constructor is a special method called __init__() that is used to initialize a newly created object.
It is automatically called when an object of a class is instantiated.
The __init__() method allows to initialize
the attributes of the object with specific values when the object is created.

# Example
class MyClass:
    def __init__(self, param1, param2):
        # Initializing object attributes
        self.param1 = param1
        self.param2 = param2

Key Points:
1.) __init__(self, ...) is the constructor.

2.) The self parameter refers to the instance of the object being created.

3.) You can pass additional arguments to the __init__() method,
which are used to set the initial values of the object's attributes.

self:- A keyword we use to access the instance variable inside class
whenever we create an object
"""

# instance variable and methods

class Dog: # blueprint

    # Contructor method

    def __init__(self,name,age):

        #instance variable.(Properties available inside Dog Class)
        self.name=name
        self.age=age

        # self.name is instance varible that is available in dog class.
        # name is the parameter that we are passing to create the object.
        # if we are adding 2 parameter in constructor variable then
        # we can create only 2 instance variable.

#create objects
dog1=Dog("maya",2)

print(dog1)
print(dog1.name)
print(dog1.age)

# Define a class with instance method


class Dog:

    def __init__(self,name,age):

        self.name=name
        self.age=age

    #A sample method
    def bark(self):
        print(f"{self.name} says woof")

dog1=Dog("Buddy",3)
dog1.bark()

dog2=Dog("Lucy",2)
dog2.bark()

# Modeling a Bank Account

# Define a class for bank account

class BankAccount:

    # create a contructor with owner and balance parameter.
    def __init__(self,owner,balance=0):

        # instance variables
        self.owner=owner
        self.balance=balance

    # define a deposit method
    def deposit(self,amount):

        self.balance+=amount
        print(f"{amount} is deposited. New balance is {self.balance}")

    # define a withdraw method]
    def withdraw(self,amount):
        if amount>self.balance:
            print("Insufficient funds!!!")
        else:
            self.balance-=amount
            print(f"{amount} is withdrawn. New balance is {self.balance}")

    # define a balance method
    def get_balance(self):
        print(f"Available balance is:- {self.balance}")

# create an object

account = BankAccount("Malav",5000)
print(account.balance)
print(account.owner)

# call instance methods

account.deposit(1000)

account.withdraw(2000)

print(account.get_balance())

"""# Inheritance in OOPs

->One of the core concept in object oriented programming language is inheritance.

->It is a mechanism that allows us to create a hirerarchy of classes that share a set of properties and methods by deriving a class from another class.

->Inheritance is the capability of one class to derive or inherit the properties from another class.

"""

# Parent class

class Car:

    def __init__(self,windows,doors,enginetype):

        self.windows=windows
        self.doors=doors
        self.enginetype=enginetype

    # method
    def drive(self):
        print(f"The person will drive the {self.enginetype} car")

car1= Car(4,5,"petrol")
print(car1)
print(car1.drive())

# inherite properties of Car class
# single inheritance

class Tesla(Car):

    def __init__(self,windows,doors,enginetype,is_selfdriving):

        # trying to call parent class
        super().__init__(windows,doors,enginetype)
        self.is_selfdriving=is_selfdriving

    def selfdriving(self):
        print(f"Tesla supports self driving: {self.is_selfdriving}")

tesla1=Tesla(4,5,"Electric",True)
print(tesla1.selfdriving())

tesla1.drive()

# Multiple Inheritance.

# When a class can be derived from more than one base class this
# type of inheritance is called multiple inheritance.

# In multiple inheritance all the features of the base classes
# are inherited into the derived class.

# Base class 1
class Animal:

    def __init__(self,name):
        self.name=name

    def speak(self):
        print(f"Subclasses must implement this method")

# Base class 2

class Pet:

    def __init__(self,owner):
        self.owner=owner

# Dervied Class

class Dog(Animal,Pet):

    def __init__(self,name,owner):
        Animal.__init__(self,name)
        Pet.__init__(self,owner)

    def speak(self):
        return f"{self.name} say woof"

# create an object

dog=Dog("MJ","Malav")
print(dog.speak())

print(f"owner: {dog.owner}")

"""# Polymorphism in OOPs

-> Polymorphism is a concept in OOP that allows one function,method, or object to behave in different ways depending on the context.

-> In Python Polymorphism lets us defined methods in the child class that have the same name as the methods in the parent class.

->In Inheritance the child class inherits the methods from the parent class. However it is possible to modify a method in a child class that it has inherited from the parent class.

Key Type of Polymorphism:-

1.) Method Overriding:
This is when a method in a child class has the same name as a method in the parent class, but the method in the child class provide a specific implementation.

2.) Method Overloading:
This is when a function or method has the same name but can accept different types or number of arguments.

However, Python does not support traditional method overloading like other languages but we can mimic with default arguments.


"""

# Method Overriding

# Method overriding allows a child class to provide a specific implementation
# of a method that is already defined in its parent class.

# Base class

class Animal:

    def speak(self):
        return "Sound of an animal."


# Derived class

class Dog(Animal):

    def speak(self):
        return "Woof!"

# Deriver class

class Cat(Animal):

    def speak(self):
        return "Meow!"

# Function that demonstrate polymorphism

def animal_speak(animal):
    print(animal.speak())



dog= Dog()
print(dog.speak())

cat= Cat()
print(cat.speak())

animal_speak(dog)

# polymorphism with functions and methods

# base class

class Shape:

    def area(self):
        return "The area of the figure"

# Derived class 1

class Rectangle(Shape):

    def __init__(self,width,height):
        self.width=width
        self.height=height

    def area(self):
        return self.width*self.height

# derived class 2

class Circle(Shape):

    def __init__(self,radius):
        self.radius=radius

    def area(self):
        return 3.14*self.radius*self.radius

# Function that demonstrate polymorphism

def print_area(shape):
    print(f"The area is {shape.area()}")


rectangle= Rectangle(4,5)
circle=Circle(3)

print_area(rectangle)
print_area(circle)

# Polymorphism with Abstract base classes

# Abstract Base Classes are used to define common methods for a group of
# related objects.
# They can enforce that derived classes implement particular methods,
# prmoting consistency across different implementations.

from abc import ABC,abstractmethod

# define abstract class

class Vehicle(ABC):
    @abstractmethod

    def start_engine(self):
        pass

# derived class

class Car(Vehicle):
    def start_engine(self):
        return "Car engine started"

# derived class

class Motorcycle(Vehicle):
    def start_engine(self):
       return "Motocycle engine started"

# Function that demonstrate polymorphism

def start_vehicle(Vehicle):
    print(Vehicle.start_engine())

# create object of car and motorcycle

car =Car()
motorcycle=Motorcycle()

start_vehicle(car)

"""# Encapsulation and Abstraction

-> Encapsulation and abstraction are two fundamental principles of object oriented programming that help in designing robuts, maintainable and resuable code.

-> Encapsulation involves bundiling data and methods that operate on the data within a single unit, while abstraction involves hiding complex implementation details and exposing only the necessary features.

# Encapsulation

-> Encapsulation is the concept of wrapping data(variables) and methods(functions) together as a single unit. It resticts direct access to some of the object's components , which is a mean of preventing accidental interference and misuse of the data.

-> Consider a real life example of encapsulation in a company there are different sections like the accounts section, finance section, sales section etc.

-> The finance section handles all the financial transactions and keeps records of all the data related to finance.

-> Similarly the sales section handles all the sales related activities and keep the record of all all the sales.

-> now there any arise a situation when due to some reason an official from the finance section needs all the data about sales in a particular month.

-> In this case,A person is not allowed to directly access the data of the sales section. He will have to contact some other officer in the sales section and then request him to give the particular data. This is what Encapsulation is.

-> Here, the data of the sales and the employees that can manipulate them are wrapped under a single name "sales section".

-> Using Encapsulation also hides the data. In this example, the data of the sections like sales, finance or accounts are hidden from any other section.
"""

# Encapsulation with getter and setter methods

# Public,Protected and Private variables or Access Modifiers

class Person:

    def __init__(self,name,age):
        self.name=name #Public Variables
        self.age=age    #Publiv Variables:- we use this variable outside of this class


# use class variable outside class

def get_name(person):
    return person.name

person =Person("Malav",28)
print(person.name)
print(person.age)


get_name(person)

dir(person) # we can see our variable at the end of the list
# these variable are called public variables.

# Private variable

class Person:

    def __init__(self,name,age,gender):
        self.__name=name  # Private Variable
        self.__age=age    # Private Variable
        self.gender=gender # Public Variable



def get_name(person):
    return person.__name

person =Person("Malav",28,"Male")


# get_name(person)
# AttributeError: 'Person' object has no attribute '__name'
# Private variable cannot be accessed from outside the class

print(person.gender)

# print(person.name)
# AttributeError: 'Person' object has no attribute 'name'#

# print(person.age)
# AttributeError: 'Person' object has no attribute 'age'

dir(person) # gender can be seen in public variable but name and age is not in the list.

# Protected variable
# It cannot be accessed outside the class but,
# it can  be accessed from a dervied class.

class Person:

    def __init__(self,name,age,gender):
        self._name=name  # Protected Variable
        self._age=age    # Protected Variable
        self.gender=gender # Public Variable

class Employee(Person):
    def __init__(self, name, age, gender):
        super().__init__(name, age, gender)

employee = Employee("Malav",28,"Male")
print(employee._name)

# Encapsulation with getter and setter method

# Getter: A method that allows you to access the value of a private attribute.
# Setter: A method that allows you to set the value of a private attribute.

class Person:
    def __init__(self,name,age):
        self.__name=name        # Private variable
        self.__age=age          # Private variable

    # getter method for name
    def get_name(self):
        return self.__name

    # setter method for name
    def set_name(self,name):
        self.__name=name

    # getter method for age
    def get_age(self):
        return self.__age

    # setter method for name
    def set_age(self,age):
        if age>0:
            self.__age=age
        else:
            print("Age cannot be negative")


person = Person("Malav",28)

# access and modify private variable using getter and setter

print(person.get_name())
print(person.get_age())

person.set_age(31)
person.set_name("Maya")
print(" ")

print(person.get_name())
print(person.get_age())

print(" ")
person.set_age(-5)
person.set_name("Mrugesh")

"""# Abstraction in OOPs

Abstraction is one of the fundamental principles of Object-Oriented Programming (OOP) that refers to the concept of hiding the implementation details and showing only the essential features of an object or class. The goal of abstraction is to reduce complexity by exposing only relevant details to the user and hiding unnecessary complexity.

Key Points about Abstraction:

1.) Hiding Complexity: Abstraction allows you to focus on what an object does, rather than how it does it.

2.) Abstract Classes: In many OOP languages, including Python, abstraction is implemented through abstract classes and abstract methods. An abstract class cannot be instantiated directly, and it usually contains one or more abstract methods that must be implemented by subclasses.

3.) Provides a High-Level Interface: An abstract class or an interface allows a high-level interface to interact with an object, while the low-level details are hidden.

Real-Life Example:

Think of a TV Remote. The TV Remote offers buttons like "Power", "Volume Up", "Volume Down", etc. You don’t need to know the internal circuit workings of the remote. You just need to know what happens when you press these buttons. The implementation of the buttons (how they work inside) is hidden from you. This is a real-world analogy of abstraction.
"""

from abc import ABC,abstractmethod

# Abstract class

class Vehicle(ABC):

    def drive(self):
        print("The vehicle is used for driving.")

    # Giving functinality with respect to drive.
    # Giving one abstract method which you can do the implementation with your own way.
    @abstractmethod
    def start_engine(self):
        pass


class Car(Vehicle):
    def start_engine(self):
        print("Car engine started")

def operate_vehicle(vehicle):
    vehicle.start_engine()

car=Car()
operate_vehicle(car)

"""# Magic Methods in Python

Magic methods (also called special methods or dunder methods) are predefined methods in Python that allow you to define how objects of a class behave with certain operations or built-in functions. These methods are prefixed and suffixed with double underscores (__) and are invoked implicitly when the corresponding operation is performed on an object.

Magic methods allow you to define how objects behave in different contexts, such as comparison, arithmetic operations, string representations, and more. They are essential for customizing the behavior of objects in your custom classes.

#1.) __init__(self,.....) - Constructor

-> This method is called when an instance of the class is created.

-> It is used to initialize the object's attributes.
"""

class Person:

    def __init__(self,name,age):
        self.name=name
        self.age=age

p=Person("Malav",28)
print(p.name,p.age)

"""#2.) __str__(self) — String Representation

-> __str__ method  is called by print() and str() to return a string representation of an object.

-> It should return a human-readable string that represents the object
"""

class Person:

    def __init__(self,name,age):
        self.name=name
        self.age=age


    def __str__(self):
        return f"{self.name} is {self.age} years old."

p=Person("Minaxi",70)
print(p)

"""#3.)  __repr__(self) — Official String Representation

-> Similar to __str__, but used for debugging.

-> __repr__ should return a string that, when passed to eval(), can recreate the object.
"""

class Person:

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def __repr__(self):
        return f"Person ('{self.name}','{self.age}')"

p=Person("Gopi",40)
print(repr(p))

"""#4.)  __len__(self) — Length

-> This method is called when len() is used on an object. It should return the length of the object.
"""

class My_List:

    def __init__(self,values):
        self.values=values

    def __len__(self):
        return len(self.values)

ls = My_List([5,10,15,20,25])
print(len(ls))

"""#5.)  __add__(self, other) — Addition

-> This method is called when the + operator is used to add two objects.
"""

class Add:

    def __init__(self,x,y):
        self.x=x
        self.y=y

    def __add__(self,other):
        return Add(self.x+other.x,self.y+other.y)

    def __repr__(self):
        return f"Add({self.x},{self.y})"

a1 = Add(1,2)
a2 = Add(1,2)

a3=a1+a2
print(a3)

"""# 6.)  __eq__(self, other) — Equality

-> This method is used when the == operator is used to compare two objects for equality.


"""

class Person:

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def __eq__(self,other):
        return self.name==other.name and self.age==other.age

p1=Person("Malav",28)
p2=Person("Malav",28)
p3=Person("Maya",60)
p
print(p1==p2)
print("")
print(p2==p3)

"""#7.) __lt__(self, other) — Less Than

-> This method is used when the < operator is used to compare two objects.
"""

class Person:

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def __lt__(self,other):
        return self.age<other.age

p1=Person("Minaxi",70)
p2=Person("Maya",64)

print(p1<p2)
print(p1>p2)

"""#8.)  __getitem__(self, key) — Item Access

-> This method is called when you access an element of an object using square brackets (e.g., obj[key]).
"""

class My_List:

    def __init__(self,values):
        self.values=values

    def __getitem__(self,index):
        return self.values[index]

ls = My_List([10,20,30,40,50])
print(ls[2])

"""# 9.) __setitem__(self, key, value) — Item Assignment

-> This method is called when you assign a value to an element of an object using square brackets (e.g., obj[key] = value).
"""

class My_List:

    def __init__(self,items):
        self.items=items

    def __setitem__(self,index,value):
        self.items[index]=value

ls = My_List([10,20,30,40,50])

ls[2]=2000

print(ls.items)

"""#10.)  __del__(self) — Destructor

-> This method is called when an object is about to be destroyed. It is used to clean up resources, close files, or release memory.
"""

class Person:

    def __init__(self):
        print("Joshi Family will buy new house in 2025")

p =Person()
print(p)
del p
#print(p) : NameError: name 'p' is not defined

"""# 11.) __call__(self, ...) — Callable Object

-> This method is invoked when an object is called like a function. It allows instances of the class to be used as callable objects.
"""

class Add:

    def __init__(self,value):
        self.value=value

    def __call__(self,other_value):
        return self.value + other_value

add_five = Add(5)
print(add_five(10))

"""# 12.)  __enter__(self) and __exit__(self) — Context Management

-> These methods are used when an object is used in a with statement.

->  __enter__ is executed when entering the with block, and __exit__ is executed when exiting the block.
"""

class MyContextManager:
    def __enter__(self):
        print("Entering the context")
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        print("Exiting the context")

with MyContextManager() as manager:
    print("Inside the context")  # Output: Inside the context
# Output: Entering the context
# Output: Exiting the context

"""# Operator Overloading in Python

Operator overloading in Python allows you to define custom behavior for the standard operators (like +, -, *, etc.) for objects of user-defined classes. This means you can modify how operators work with objects of your classes, enabling your custom classes to interact naturally with Python's built-in operations.

When an operator is used with an object, Python internally calls the corresponding magic method (special method or dunder method). These magic methods are methods with double underscores, such as __add__ for +, __sub__ for -, and so on.

By overloading these magic methods, you can customize the behavior of operators for your custom objects.

-> __add__(self,other) :  Adds two objects using the + operator

-> __sub__(self,other) : Subtracts two objects using the _ operator

-> __mul__(self,other) : Multiplies two objects using the * operator

-> __truediv__(self,other): Divides two objects using the / operator

-> __eq_(self,other) : Check if two objects are equal using the == operator

-> __lt__(self,other) : Checks if one object is less than another using the < operator

-> __gt__(self,other) : Checks if one object is grater than another using the >operator
"""

class Vector:

    def __init__(self,x,y):
        self.x=x
        self.y=y

    def __add__(self,other):
        return Vector(self.x+other.x,self.y+other.y)

    def __sub__(self,other):
        return Vector(self.x-other.x,self.y-other.y)

    def __mul__(self,other):
        return Vector(self.x*other.x,self.y*other.y)

    def __truediv__(self,other):
        return Vector(self.x/other.x,self.y/other.y)

    def __eq__(self,other):
        return Vector(self.x==other.x,self.y==other.y)

    def __repr__(self):
        return f"Vector({self.x},{self.y})"

# craete object
v1 = Vector(2,3)
v2= Vector(4,5)


print("add: ",v1+v2)

print("sub: ",v1-v2)

print("mul: ",v1*v2)

print("truediv: ",v1/v2)

print("Equal ?: ",v1==v2)

"""# Custom Exception (Raise and Throw an exception)

"""

class Error(Exception):
    pass

class dobException(Error):
    pass

# craete a form

year = int(input("Enter the Data of birth:- "))
age = 2024-year

try:
    if age<=30 and age>=20:
        print("Age is valid. So please apply for the exam.")
    else:
        raise dobException
except dobException:
    print("Age is not valid.Age should be greater than 20 or less than 30.")

year = int(input("Enter the Data of birth:- "))
age = 2024-year

try:
    if age<=30 and age>=20:
        print("Age is valid. So please apply for the exam.")
    else:
        raise dobException

except dobException:
    print("Age is not valid.Age should be greater than 20 or less than 30.")